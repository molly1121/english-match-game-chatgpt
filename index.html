<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>è€å¹´å‹å¥½çš„è‹±è¯­å•è¯æ¶ˆæ¶ˆä¹â€”æµ·å…³è¯æ±‡ï¼ˆä¸‰å…³ï¼‰</title>
    <!-- Tailwind Play CDN (OK for demos/sharing) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = { theme: { extend: {} } };
    </script>
    <style>
      html, body { height: 100%; }
    </style>
  </head>
  <body class="min-h-screen bg-white">
    <div id="root"></div>

    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel Standalone to transpile TSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="typescript,react">
      // === Adapted App from canvas: imports/exports removed; default export -> App ===

      // â€”â€” å¸¸é‡ï¼ˆä¾›ç»„ä»¶ä¸æµ‹è¯•å…±ç”¨ï¼‰ â€”â€”
      const DEFAULT_ROWS = 6;
      const DEFAULT_COLS = 6;
      const TEST_CELL = 96;

      const SWIPE_COMMIT = Math.min(48, Math.max(32, Math.round(TEST_CELL * 0.45)));
      const SWIPE_PREVIEW = Math.round(SWIPE_COMMIT * 0.6);

      const LEVEL_TARGET = { 1: 150, 2: 220, 3: 0 };
      function shouldUnlockNext(currentLevel, score) {
        if (currentLevel === 1) return score >= LEVEL_TARGET[1];
        if (currentLevel === 2) return score >= LEVEL_TARGET[2];
        return false;
      }

      function fitFontPx(word, base, cellPx) {
        const PADDING_X = 16;
        const inner = Math.max(0, cellPx - PADDING_X);
        const avgCharWidthCoeff = 0.6;
        const len = Math.max(1, word.length);
        const maxSizeByWidth = Math.floor(inner / (len * avgCharWidthCoeff));
        const MIN = 12;
        return Math.max(MIN, Math.min(base, maxSizeByWidth));
      }

      function directionFromDelta(dx, dy, threshold = 24) {
        const ax = Math.abs(dx), ay = Math.abs(dy);
        if (ax < threshold && ay < threshold) return null;
        if (ax > ay) return dx > 0 ? "right" : "left";
        return dy > 0 ? "down" : "up";
      }

      function neighborFromDirection(r, c, dir, rows = DEFAULT_ROWS, cols = DEFAULT_COLS) {
        switch (dir) {
          case "left": return c > 0 ? { r, c: c - 1 } : null;
          case "right": return c < cols - 1 ? { r, c: c + 1 } : null;
          case "up": return r > 0 ? { r: r - 1, c } : null;
          case "down": return r < rows - 1 ? { r: r + 1, c } : null;
          default: return null;
        }
      }

      function safeIndex(i, len) {
        if (len <= 0) return 0;
        if (i >= 0 && i < len) return i;
        return ((i % len) + len) % len;
      }

      function fisherYates(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const t = a[i]; a[i] = a[j]; a[j] = t;
        }
        return a;
      }

      function hasImmediateMatches(g, rows, cols) {
        for (let r = 0; r < rows; r++) {
          let runStart = 0;
          for (let c = 1; c <= cols; c++) {
            if (c < cols && g[r][c] === g[r][c - 1]) continue;
            const runLen = c - runStart;
            if (runLen >= 3) return true;
            runStart = c;
          }
        }
        for (let c = 0; c < cols; c++) {
          let runStart = 0;
          for (let r = 1; r <= rows; r++) {
            if (r < rows && g[r][c] === g[r - 1][c]) continue;
            const runLen = r - runStart;
            if (runLen >= 3) return true;
            runStart = r;
          }
        }
        return false;
      }

      const LEVELS = {
        1: [
          { key: "passport", cn: "æŠ¤ç…§", ipa: "ËˆpÉ‘ËspÉ”Ët", phrase: "Show your passport." },
          { key: "visa", cn: "ç­¾è¯", ipa: "ËˆviËzÉ™", phrase: "Do you have a visa?" },
          { key: "customs", cn: "æµ·å…³", ipa: "ËˆkÊŒstÉ™mz", phrase: "Go to customs." },
          { key: "officer", cn: "å·¥ä½œäººå‘˜/å®˜å‘˜", ipa: "ËˆÉ’fÉªsÉ™", phrase: "Ask the officer." },
          { key: "luggage", cn: "è¡Œæ", ipa: "ËˆlÊŒÉ¡ÉªdÊ’", phrase: "Check your luggage." },
          { key: "declare", cn: "ç”³æŠ¥", ipa: "dÉªËˆkleÉ™", phrase: "I need to declare." },
        ],
        2: [
          { key: "form", cn: "è¡¨æ ¼", ipa: "fÉ”Ëm", phrase: "Fill in the form." },
          { key: "stamp", cn: "ç›–ç« /æˆ³è®°", ipa: "stÃ¦mp", phrase: "Get a stamp." },
          { key: "entry", cn: "å…¥å¢ƒ", ipa: "ËˆÉ›ntri", phrase: "Entry to the country." },
          { key: "exit", cn: "å‡ºå¢ƒ/å‡ºå£", ipa: "ËˆÉ›ksÉªt", phrase: "Exit is there." },
          { key: "suitcase", cn: "æ‰‹æç®±/è¡Œæç®±", ipa: "ËˆsuËtkeÉªs", phrase: "My suitcase is heavy." },
          { key: "queue", cn: "æ’é˜Ÿ", ipa: "kjuË", phrase: "Please join the queue." },
          { key: "scan", cn: "æ‰«æ", ipa: "skÃ¦n", phrase: "We will scan your bag." },
          { key: "address", cn: "åœ°å€", ipa: "É™ËˆdrÉ›s", phrase: "Your address, please." },
          { key: "stay", cn: "åœç•™/é€—ç•™", ipa: "steÉª", phrase: "How long will you stay?" },
          { key: "purpose", cn: "ç›®çš„", ipa: "ËˆpÉœËpÉ™s", phrase: "What is the purpose?" },
        ],
        3: [
          { key: "duty", cn: "å…³ç¨", ipa: "ËˆdjuËti", phrase: "Pay the duty." },
          { key: "tax", cn: "ç¨", ipa: "tÃ¦ks", phrase: "This tax is included." },
          { key: "value", cn: "ä»·å€¼/ç”³æŠ¥ä»·å€¼", ipa: "ËˆvÃ¦ljuË", phrase: "What is the value?" },
          { key: "cash", cn: "ç°é‡‘", ipa: "kÃ¦Êƒ", phrase: "How much cash?" },
          { key: "currency", cn: "è´§å¸", ipa: "ËˆkÊŒrÉ™nsi", phrase: "Declare your currency." },
          { key: "alcohol", cn: "é…’ç²¾é¥®å“", ipa: "ËˆÃ¦lkÉ™hÉ’l", phrase: "Any alcohol?" },
          { key: "tobacco", cn: "çƒŸè‰", ipa: "tÉ™ËˆbÃ¦kÉ™ÊŠ", phrase: "Any tobacco?" },
          { key: "medicine", cn: "è¯å“", ipa: "ËˆmÉ›dÉªsÉªn", phrase: "Do you carry medicine?" },
          { key: "food", cn: "é£Ÿå“", ipa: "fuËd", phrase: "Any food?" },
          { key: "plant", cn: "æ¤ç‰©", ipa: "plÉ‘Ënt", phrase: "Any plants?" },
          { key: "animal", cn: "åŠ¨ç‰©", ipa: "ËˆÃ¦nÉªmÉ™l", phrase: "Any animal products?" },
          { key: "quarantine", cn: "æ£€ç–«/éš”ç¦»", ipa: "ËˆkwÉ’rÉ™ntiËn", phrase: "This item is in quarantine." },
          { key: "inspection", cn: "æ£€æŸ¥", ipa: "ÉªnËˆspÉ›kÊƒÉ™n", phrase: "We need an inspection." },
          { key: "receipt", cn: "æ”¶æ®", ipa: "rÉªËˆsiËt", phrase: "Keep the receipt." },
        ],
      };

      function App() {
        const ROWS = DEFAULT_ROWS;
        const COLS = DEFAULT_COLS;
        const MOVES = 20;

        const [level, setLevel] = React.useState(1);
        const WORDS = React.useMemo(() => LEVELS[level], [level]);

        const [unlocked, setUnlocked] = React.useState(() => {
          try {
            const raw = localStorage.getItem("wm_unlocked");
            if (raw) {
              const arr = JSON.parse(raw);
              return new Set(arr);
            }
          } catch {}
          return new Set([1]);
        });
        React.useEffect(() => {
          try { localStorage.setItem("wm_unlocked", JSON.stringify(Array.from(unlocked))); } catch {}
        }, [unlocked]);

        const COLOR_BY_INDEX = [
          "bg-blue-100 border-blue-300",
          "bg-green-100 border-green-300",
          "bg-yellow-100 border-yellow-300",
          "bg-purple-100 border-purple-300",
          "bg-rose-100 border-rose-300",
          "bg-teal-100 border-teal-300",
          "bg-orange-100 border-orange-300",
          "bg-sky-100 border-sky-300",
        ];

        const [grid, setGrid] = React.useState(() => createInitialGrid(ROWS, COLS, WORDS.length));
        const [selected, setSelected] = React.useState(null);
        const swipeRef = React.useRef(null);
        const [dragTarget, setDragTarget] = React.useState(null);
        const justSwappedRef = React.useRef(false);
        const [score, setScore] = React.useState(0);
        const [movesLeft, setMovesLeft] = React.useState(MOVES);
        const [lastMatch, setLastMatch] = React.useState([]);
        const [bigFont, setBigFont] = React.useState(true);
        const [showChinese, setShowChinese] = React.useState(true);
        const [speakOnMatch, setSpeakOnMatch] = React.useState(true);
        const [isBusy, setIsBusy] = React.useState(false);
        const [passInfo, setPassInfo] = React.useState(null);

        const firstLoad = React.useRef(true);
        React.useEffect(() => {
          if (firstLoad.current) { firstLoad.current = false; return; }
          resetGameForKinds(WORDS.length);
        }, [level]);

        const speak = (text) => {
          try {
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "en-GB"; u.rate = 0.9;
            window.speechSynthesis?.speak(u);
          } catch {}
        };

        function createInitialGrid(rows, cols, kinds) {
          const g = Array.from({ length: rows }, () => Array(cols).fill(0));
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              let tries = 0;
              do {
                g[r][c] = Math.floor(Math.random() * kinds);
                tries++;
              } while ((createsRun(g, r, c, cols) || createsRunVertical(g, r, c, rows)) && tries < 50);
            }
          }
          return g;
        }
        function createsRun(g, r, c, COLS_LOCAL) {
          const v = g[r][c];
          return (
            (c >= 2 && g[r][c - 1] === v && g[r][c - 2] === v) ||
            (c >= 1 && c + 1 < COLS_LOCAL && g[r][c - 1] === v && g[r][c + 1] === v) ||
            (c + 2 < COLS_LOCAL && g[r][c + 1] === v && g[r][c + 2] === v)
          );
        }
        function createsRunVertical(g, r, c, ROWS_LOCAL) {
          const v = g[r][c];
          return (
            (r >= 2 && g[r - 1][c] === v && g[r - 2][c] === v) ||
            (r >= 1 && r + 1 < ROWS_LOCAL && g[r - 1][c] === v && g[r + 1][c] === v) ||
            (r + 2 < ROWS_LOCAL && g[r + 1][c] === v && g[r + 2][c] === v)
          );
        }
        function findMatches(g) {
          const toClear = new Set();
          for (let r = 0; r < ROWS; r++) {
            let runStart = 0;
            for (let c = 1; c <= COLS; c++) {
              if (c < COLS && g[r][c] === g[r][c - 1]) continue;
              const runLen = c - runStart;
              if (runLen >= 3) { for (let k = runStart; k < c; k++) toClear.add(`${r},${k}`); }
              runStart = c;
            }
          }
          for (let c = 0; c < COLS; c++) {
            let runStart = 0;
            for (let r = 1; r <= ROWS; r++) {
              if (r < ROWS && g[r][c] === g[r - 1][c]) continue;
              const runLen = r - runStart;
              if (runLen >= 3) { for (let k = runStart; k < r; k++) toClear.add(`${k},${c}`); }
              runStart = r;
            }
          }
          const coords = [];
          toClear.forEach((key) => {
            const [rs, cs] = key.split(",").map(Number);
            coords.push({ r: rs, c: cs, v: g[rs][cs] });
          });
          return coords;
        }
        function cloneGrid(g) { return g.map((row) => row.slice()); }
        function collapseAndRefill(g) {
          for (let c = 0; c < COLS; c++) {
            let write = ROWS - 1;
            for (let r = ROWS - 1; r >= 0; r--) {
              if (g[r][c] !== -1) { g[write][c] = g[r][c]; write--; }
            }
            for (let r = write; r >= 0; r--) {
              g[r][c] = Math.floor(Math.random() * WORDS.length);
            }
          }
        }
        async function resolveMatchesCascade(base) {
          let totalCleared = 0;
          let g = cloneGrid(base);
          let uniqueWords = new Set();
          while (true) {
            const matches = findMatches(g);
            if (matches.length === 0) break;
            totalCleared += matches.length;
            matches.forEach((m) => uniqueWords.add(m.v));
            matches.forEach(({ r, c }) => (g[r][c] = -1));
            collapseAndRefill(g);
          }
          return { g, totalCleared, uniqueWords: Array.from(uniqueWords) };
        }
        function areAdjacent(a, b) {
          const dr = Math.abs(a.r - b.r);
          const dc = Math.abs(a.c - b.c);
          return dr + dc === 1;
        }
        async function trySwap(a, b) {
          if (!areAdjacent(a, b)) return;
          setIsBusy(true);
          const g = cloneGrid(grid);
          const tmp = g[a.r][a.c]; g[a.r][a.c] = g[b.r][b.c]; g[b.r][b.c] = tmp;
          const initialMatches = findMatches(g);
          if (initialMatches.length === 0) { setSelected(null); setIsBusy(false); return; }

          const { g: after, totalCleared, uniqueWords } = await resolveMatchesCascade(g);
          setGrid(after);

          const gained = totalCleared * 10;
          const newScore = score + gained;
          if ((level === 1 || level === 2) && shouldUnlockNext(level, newScore)) {
            const nextLv = (level === 1 ? 2 : 3);
            if (!unlocked.has(nextLv) && !passInfo) {
              setUnlocked((prevSet) => {
                const next = new Set(prevSet); next.add(nextLv); return next;
              });
              setPassInfo({ level, next: nextLv });
              try { window.setTimeout(() => { setPassInfo(null); setLevel(nextLv); }, 1800); } catch {}
            }
          }
          setScore(newScore);
          setMovesLeft((m) => Math.max(0, m - 1));
          setLastMatch(uniqueWords);
          if (speakOnMatch && uniqueWords.length > 0) speak(WORDS[safeIndex(uniqueWords[0], WORDS.length)].key);
          setSelected(null);
          setIsBusy(false);
        }

        const CELL = bigFont ? 96 : 80;
        const COMMIT_THRES = Math.min(48, Math.max(32, Math.round(CELL * 0.45)));
        const PREVIEW_THRES = Math.round(COMMIT_THRES * 0.6);

        const onPointerDownTile = (r, c) => (e) => {
          try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
          swipeRef.current = { r, c, x: e.clientX, y: e.clientY, id: e.pointerId };
          setSelected({ r, c });
        };
        const onPointerMoveTile = (r, c) => (e) => {
          const s = swipeRef.current;
          if (!s || s.id !== e.pointerId) return;
          const dx = e.clientX - s.x;
          const dy = e.clientY - s.y;
          const dirPreview = directionFromDelta(dx, dy, PREVIEW_THRES);
          if (!dirPreview) { setDragTarget(null); return; }
          const nbr = neighborFromDirection(s.r, s.c, dirPreview, ROWS, COLS);
          setDragTarget(nbr);
        };
        const onPointerUpTile = (r, c) => (e) => {
          const s = swipeRef.current;
          const dx = s ? e.clientX - s.x : 0;
          const dy = s ? e.clientY - s.y : 0;
          const dir = directionFromDelta(dx, dy, COMMIT_THRES);
          if (s && s.id === e.pointerId && dir && !isBusy && movesLeft > 0) {
            const nbr = neighborFromDirection(s.r, s.c, dir, ROWS, COLS);
            if (nbr) { justSwappedRef.current = true; trySwap({ r: s.r, c: s.c }, nbr); }
          }
          setSelected(null); setDragTarget(null); swipeRef.current = null;
        };
        const onTileClick = (r, c) => {
          if (justSwappedRef.current) { justSwappedRef.current = false; return; }
          if (isBusy || movesLeft === 0) return;
          if (!selected) {
            setSelected({ r, c });
          } else {
            const here = { r, c };
            if (selected.r === r && selected.c === c) setSelected(null);
            else if (areAdjacent(selected, here)) trySwap(selected, here);
            else setSelected(here);
          }
        };

        const resetGameForKinds = (kinds) => {
          setGrid(createInitialGrid(ROWS, COLS, kinds));
          setSelected(null); setScore(0); setMovesLeft(MOVES); setLastMatch([]);
        };
        const resetGame = () => resetGameForKinds(WORDS.length);

        const shuffleBoard = () => {
          if (isBusy) return;
          const flat = grid.flat();
          const kinds = WORDS.length;
          if (kinds <= 1) return;
          let tries = 0;
          while (tries < 40) {
            const shuffled = fisherYates(flat);
            const g2 = Array.from({ length: ROWS }, (_, r) => shuffled.slice(r * COLS, (r + 1) * COLS));
            if (!hasImmediateMatches(g2, ROWS, COLS)) {
              setGrid(g2); setSelected(null); setDragTarget(null); setLastMatch([]); return;
            }
            tries++;
          }
          setGrid(createInitialGrid(ROWS, COLS, kinds));
          setSelected(null); setDragTarget(null); setLastMatch([]);
        };

        const chooseLevel = (lv) => {
          if (lv === level) return;
          if (!unlocked.has(lv)) return;
          setLevel(lv);
        };

        return (
          <div className="min-h-screen w-full bg-white text-gray-900 flex flex-col items-center p-4 md:p-6">
            <div className="w-full max-w-6xl">
              <header className="flex flex-col md:flex-row md:items-end md:justify-between gap-3 mb-4">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold">æ¶ˆæ¶ˆä¹å­¦å•è¯ï¼ˆæµ·å…³è¯æ±‡Â·ä¸‰å…³ï¼‰</h1>
                  <p className="text-gray-700 mt-1">ç©æ³•ï¼ˆæ‰‹æœºï¼‰ï¼šæŒ‰ä½æ ¼å­å‘ä¸Šä¸‹å·¦å³æ»‘åŠ¨è¿›è¡Œäº¤æ¢ï¼›ï¼ˆç”µè„‘ï¼‰ï¼šç‚¹å‡»ä¸€ä¸ªæ ¼å­å†ç‚¹ç›¸é‚»æ ¼å­ã€‚è¿æˆ3ä¸ªæˆ–ä»¥ä¸Šç›¸åŒå•è¯å³å¯æ¶ˆé™¤å¹¶å­¦ä¹ ã€‚</p>
                </div>
                <div className="flex gap-2 flex-wrap items-center">
                  <div className="flex gap-2">
                    {[1,2,3].map((lv) => (
                      <button
                        key={lv}
                        onClick={() => chooseLevel(lv)}
                        disabled={!unlocked.has(lv)}
                        className={`px-4 py-2 rounded-2xl shadow border text-base md:text-lg ${level === lv ? "bg-blue-50 border-blue-300" : ""} ${!unlocked.has(lv) ? "opacity-60 cursor-not-allowed" : ""}`}
                        aria-pressed={level === lv}
                        aria-disabled={!unlocked.has(lv)}
                      >{lv === 1 ? "ç¬¬ä¸€å…³ï¼ˆ6è¯ï¼‰" : lv === 2 ? "ç¬¬äºŒå…³ï¼ˆ10è¯ï¼‰" : "ç¬¬ä¸‰å…³ï¼ˆ14è¯ï¼‰"}</button>
                    ))}
                  </div>
                  <button onClick={() => setBigFont(v => !v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={bigFont}>
                    {bigFont ? "å¤§å­—æ¨¡å¼ï¼šå¼€" : "å¤§å­—æ¨¡å¼ï¼šå…³"}
                  </button>
                  <button onClick={() => setShowChinese(v => !v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={showChinese}>
                    {showChinese ? "ä¸­æ–‡æç¤ºï¼šå¼€" : "ä¸­æ–‡æç¤ºï¼šå…³"}
                  </button>
                  <button onClick={() => setSpeakOnMatch(v => !v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={speakOnMatch}>
                    {speakOnMatch ? "è¯»éŸ³ï¼šå¼€" : "è¯»éŸ³ï¼šå…³"}
                  </button>
                  <button onClick={resetGame} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg">é‡æ–°å¼€å§‹</button>
                  <button onClick={shuffleBoard} disabled={isBusy} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-label="æ‰“ä¹±å½“å‰æ£‹ç›˜ï¼Œä¸æ‰£æ­¥">
                    æ‰“ä¹±ä¸€ä¸‹ï¼ˆä¸æ‰£æ­¥ï¼‰
                  </button>
                </div>
              </header>

              <main className="grid md:grid-cols-[1fr_auto_1fr] gap-4">
                <aside className="rounded-2xl border p-4 shadow-sm">
                  <div className="text-lg md:text-xl font-semibold mb-2">æœ¬å…³ç›®æ ‡ï¼ˆå…³å¡ï¼š{level}ï¼‰</div>
                  <ul className="text-base leading-relaxed">
                    <li>Â· è®¤è¯†å¹¶èƒ½è¯»å‡ºæœ¬å…³æµ·å…³è¯æ±‡</li>
                    <li>Â· æ¯æ¬¡æ¶ˆé™¤åçœ‹å¡ç‰‡ï¼Œè·Ÿè¯» 1 é</li>
                  </ul>
                  <div className="mt-3 text-base">
                    <div>æ­¥æ•°ï¼š<span className="font-bold">{movesLeft}</span></div>
                    <div>å¾—åˆ†ï¼š<span className="font-bold">{score}</span></div>
                    {(level === 1 || level === 2) && (
                      <div className="mt-1 text-sm text-gray-600">è¾¾åˆ° <b>{LEVEL_TARGET[level]}</b> åˆ†å°†è§£é”ä¸‹ä¸€å…³</div>
                    )}
                  </div>
                  <div className="mt-4">
                    <div className="text-base md:text-lg font-medium mb-2">æœ¬å…³è¯æ±‡ï¼ˆ{WORDS.length}ä¸ªï¼‰</div>
                    <div className="flex flex-wrap gap-2">
                      {WORDS.map((w) => (
                        <span key={w.key} className="px-2 py-1 rounded-xl border text-sm md:text-base">
                          {w.key} {showChinese ? `Â· ${w.cn}` : ""}
                        </span>
                      ))}
                    </div>
                  </div>
                </aside>

                <section className="flex flex-col items-center">
                  <div
                    className="grid"
                    style={{ gridTemplateColumns: `repeat(${COLS}, ${CELL}px)`, gridTemplateRows: `repeat(${ROWS}, ${CELL}px)`, gap: bigFont ? 8 : 6, touchAction: "none" }}
                  >
                    {grid.map((row, r) => row.map((v, c) => {
                      const isSel = selected?.r === r && selected?.c === c;
                      const classColor = COLOR_BY_INDEX[v % COLOR_BY_INDEX.length];
                      const tileBase = `select-none ${classColor} border-2 rounded-2xl shadow-sm flex items-center justify-center cursor-pointer hover:shadow-md transition text-center whitespace-nowrap truncate leading-tight px-2 overflow-hidden`;
                      const keyStr = WORDS[safeIndex(v, WORDS.length)].key;
                      return (
                        <button
                          key={`${r}-${c}`}
                          onClick={() => onTileClick(r, c)}
                          onPointerDown={onPointerDownTile(r, c)}
                          onPointerMove={onPointerMoveTile(r, c)}
                          onPointerUp={onPointerUpTile(r, c)}
                          className={
                            tileBase +
                            (isSel ? " ring-4 ring-blue-400" : "") +
                            (dragTarget && dragTarget.r === r && dragTarget.c === c ? " ring-4 ring-emerald-400" : "") +
                            (isBusy ? " opacity-80" : "")
                          }
                          style={{ fontSize: fitFontPx(keyStr, bigFont ? 26 : 22, CELL), fontWeight: 800, lineHeight: 1.1 }}
                          aria-label={`ç¬¬${r + 1}è¡Œç¬¬${c + 1}åˆ—ï¼š${keyStr}`}
                        >
                          {keyStr}
                        </button>
                      );
                    }))}
                  </div>
                  {movesLeft === 0 && (
                    <div className="mt-4 p-4 rounded-2xl border shadow bg-gray-50 text-center">
                      <div className="text-lg md:text-xl font-bold mb-1">æœ¬å±€ç»“æŸ</div>
                      <div className="mb-2">å¾—åˆ†ï¼š{score}ã€‚{(level === 1 || level === 2) ? `è¾¾åˆ° ${LEVEL_TARGET[level]} åˆ†å°†è§£é”ä¸‹ä¸€å…³ã€‚` : "å·²æ˜¯æœ€åä¸€å…³ã€‚"}</div>
                      <button onClick={resetGame} className="px-4 py-2 rounded-2xl shadow border">å†æ¥ä¸€å±€</button>
                    </div>
                  )}
                </section>

                <aside className="rounded-2xl border p-4 shadow-sm">
                  <div className="text-lg md:text-xl font-semibold mb-2">å­¦ä¹ å¡ç‰‡</div>
                  {lastMatch.length === 0 ? (
                    <p className="text-base text-gray-600">æ¶ˆé™¤åä¼šåœ¨è¿™é‡Œå‡ºç°å¡ç‰‡ã€‚</p>
                  ) : (
                    <div className="space-y-3">
                      {lastMatch.map((idx) => {
                        const w = WORDS[safeIndex(idx, WORDS.length)];
                        return (
                          <div key={w.key} className="p-3 rounded-xl border bg-white shadow-sm">
                            <div className="flex items-center justify-between">
                              <div className="text-xl md:text-2xl font-bold">{w.key}</div>
                              <button className="px-3 py-1 rounded-xl border text-sm" onClick={() => speak(w.key)} aria-label={`æ’­æ”¾ ${w.key} çš„è¯»éŸ³`}>ğŸ”Š å‘éŸ³</button>
                            </div>
                            <div className="text-sm text-gray-600 mt-1">/{w.ipa}/</div>
                            {showChinese && <div className="mt-1 text-base">ä¸­æ–‡ï¼š{w.cn}</div>}
                            <div className="mt-1 text-base italic">ä¾‹å¥ï¼š{w.phrase}</div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                  <div className="mt-4 text-sm text-gray-600 leading-relaxed">å°è´´å£«ï¼šé•¿æŒ‰â€œğŸ”Š å‘éŸ³â€åè·Ÿè¯» 1 éï¼›æ¯å¤©ç© 10 åˆ†é’Ÿï¼Œè¿›æ­¥æ›´å¿«ã€‚</div>
                </aside>
              </main>

              <footer className="mt-6 text-sm text-gray-500">
                æ— è®¡æ—¶ Â· è¯¯è§¦å¯å–æ¶ˆé€‰æ‹© Â· é«˜å¯¹æ¯”åº¦é…è‰² Â· å¯åˆ‡æ¢ä¸­æ–‡æç¤ºä¸è¯»éŸ³
              </footer>
            </div>

            {passInfo && (
              <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50">
                <div className="bg-white rounded-2xl shadow-xl p-6 w-[min(90vw,520px)] text-center">
                  <div className="text-2xl font-bold mb-2">ğŸ‰ æ­å–œè¿‡å…³ï¼</div>
                  <div className="text-base mb-3">
                    ä½ å·²è¾¾åˆ°æœ¬å…³ç›®æ ‡åˆ†æ•°ï¼ˆâ‰¥ {LEVEL_TARGET[level]} åˆ†ï¼‰ã€‚å°†è¿›å…¥
                    <b> ç¬¬{passInfo.next === 2 ? "äºŒ" : "ä¸‰"}å…³</b> â€¦
                  </div>
                  <div className="text-sm text-gray-600 mb-4">å°†è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³ï¼ˆçº¦ 1.8 ç§’ï¼‰ã€‚</div>
                  <div className="flex justify-center gap-2">
                    <button className="px-4 py-2 rounded-2xl border shadow" onClick={() => { setPassInfo(null); setLevel(passInfo.next); }}>
                      ç«‹å³è¿›å…¥
                    </button>
                    <button className="px-4 py-2 rounded-2xl border" onClick={() => setPassInfo(null)}>
                      ç¨å
                    </button>
                  </div>
                </div>
                <span className="sr-only" aria-live="assertive">æ­å–œè¿‡å…³ï¼Œæ­£åœ¨ä¸ºä½ è¿›å…¥ä¸‹ä¸€å…³</span>
              </div>
            )}
          </div>
        );
      }

      // Mount
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
