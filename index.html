<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>è€å¹´å‹å¥½çš„è‹±è¯­å•è¯æ¶ˆæ¶ˆä¹â€”æµ·å…³è¯æ±‡ï¼ˆä¸‰å…³ï¼‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = { theme: { extend: {} } };</script>
    <style>html,body{height:100%}</style>
  </head>
  <body class="min-h-screen bg-white">
    <div id="root"></div>

    <!-- React 18 UMD & Babelï¼ˆåœ¨æµè§ˆå™¨é‡Œç›´æ¥è¿è¡Œ TSX/JSXï¼‰ -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="typescript,react">
      const DEFAULT_ROWS = 6, DEFAULT_COLS = 6, TEST_CELL = 96;
      const SWIPE_COMMIT = Math.min(48, Math.max(32, Math.round(TEST_CELL * 0.45)));
      const SWIPE_PREVIEW = Math.round(SWIPE_COMMIT * 0.6);
      const LEVEL_TARGET = {1:150,2:220,3:0};
      const shouldUnlockNext = (lv, s) => (lv===1? s>=LEVEL_TARGET[1] : lv===2? s>=LEVEL_TARGET[2] : false);

      const fitFontPx = (word, base, cell) => {
        const inner = Math.max(0, cell - 16);
        const len = Math.max(1, word.length);
        const maxSize = Math.floor(inner / (len * 0.6));
        return Math.max(12, Math.min(base, maxSize));
      };
      const directionFromDelta = (dx,dy,t=24)=>{const ax=Math.abs(dx),ay=Math.abs(dy);if(ax<t&&ay<t)return null;return ax>ay?(dx>0?'right':'left'):(dy>0?'down':'up')};
      const neighborFromDirection = (r,c,dir,rows=DEFAULT_ROWS,cols=DEFAULT_COLS)=>({left:()=>c>0?{r,c:c-1}:null,right:()=>c<cols-1?{r,c:c+1}:null,up:()=>r>0?{r:r-1,c}:null,down:()=>r<rows-1?{r:r+1,c}:null}[dir]());
      const safeIndex=(i,len)=>len<=0?0: (i>=0&&i<len?i:(((i%len)+len)%len));
      const fisherYates=a=>{a=a.slice();for(let i=a.length-1;i>0;i++){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
      const hasImmediateMatches=(g,rows,cols)=>{for(let r=0;r<rows;r++){let s=0;for(let c=1;c<=cols;c++){if(c<cols&&g[r][c]===g[r][c-1])continue;const L=c-s;if(L>=3)return true;s=c}}for(let c=0;c<cols;c++){let s=0;for(let r=1;r<=rows;r++){if(r<rows&&g[r][c]===g[r-1][c])continue;const L=r-s;if(L>=3)return true;s=r}}return false};
      const computeCellPx=(avail,cols,gap,maxCell,minCell=52)=>{const inner=Math.max(0,avail-(cols-1)*gap);const raw=Math.floor(inner/cols);return Math.max(minCell,Math.min(maxCell,raw))};

      const LEVELS={
        1:[{key:'passport',cn:'æŠ¤ç…§',ipa:'ËˆpÉ‘ËspÉ”Ët',phrase:'Show your passport.'},
           {key:'visa',cn:'ç­¾è¯',ipa:'ËˆviËzÉ™',phrase:'Do you have a visa?'},
           {key:'customs',cn:'æµ·å…³',ipa:'ËˆkÊŒstÉ™mz',phrase:'Go to customs.'},
           {key:'officer',cn:'å·¥ä½œäººå‘˜/å®˜å‘˜',ipa:'ËˆÉ’fÉªsÉ™',phrase:'Ask the officer.'},
           {key:'luggage',cn:'è¡Œæ',ipa:'ËˆlÊŒÉ¡ÉªdÊ’',phrase:'Check your luggage.'},
           {key:'declare',cn:'ç”³æŠ¥',ipa:'dÉªËˆkleÉ™',phrase:'I need to declare.'}],
        2:[{key:'form',cn:'è¡¨æ ¼',ipa:'fÉ”Ëm',phrase:'Fill in the form.'},
           {key:'stamp',cn:'ç›–ç« /æˆ³è®°',ipa:'stÃ¦mp',phrase:'Get a stamp.'},
           {key:'entry',cn:'å…¥å¢ƒ',ipa:'ËˆÉ›ntri',phrase:'Entry to the country.'},
           {key:'exit',cn:'å‡ºå¢ƒ/å‡ºå£',ipa:'ËˆÉ›ksÉªt',phrase:'Exit is there.'},
           {key:'suitcase',cn:'æ‰‹æç®±/è¡Œæç®±',ipa:'ËˆsuËtkeÉªs',phrase:'My suitcase is heavy.'},
           {key:'queue',cn:'æ’é˜Ÿ',ipa:'kjuË',phrase:'Please join the queue.'},
           {key:'scan',cn:'æ‰«æ',ipa:'skÃ¦n',phrase:'We will scan your bag.'},
           {key:'address',cn:'åœ°å€',ipa:'É™ËˆdrÉ›s',phrase:'Your address, please.'},
           {key:'stay',cn:'åœç•™/é€—ç•™',ipa:'steÉª',phrase:'How long will you stay?'},
           {key:'purpose',cn:'ç›®çš„',ipa:'ËˆpÉœËpÉ™s',phrase:'What is the purpose?'}],
        3:[{key:'duty',cn:'å…³ç¨',ipa:'ËˆdjuËti',phrase:'Pay the duty.'},
           {key:'tax',cn:'ç¨',ipa:'tÃ¦ks',phrase:'This tax is included.'},
           {key:'value',cn:'ä»·å€¼/ç”³æŠ¥ä»·å€¼',ipa:'ËˆvÃ¦ljuË',phrase:'What is the value?'},
           {key:'cash',cn:'ç°é‡‘',ipa:'kÃ¦Êƒ',phrase:'How much cash?'},
           {key:'currency',cn:'è´§å¸',ipa:'ËˆkÊŒrÉ™nsi',phrase:'Declare your currency.'},
           {key:'alcohol',cn:'é…’ç²¾é¥®å“',ipa:'ËˆÃ¦lkÉ™hÉ’l',phrase:'Any alcohol?'},
           {key:'tobacco',cn:'çƒŸè‰',ipa:'tÉ™ËˆbÃ¦kÉ™ÊŠ',phrase:'Any tobacco?'},
           {key:'medicine',cn:'è¯å“',ipa:'ËˆmÉ›dÉªsÉªn',phrase:'Do you carry medicine?'},
           {key:'food',cn:'é£Ÿå“',ipa:'fuËd',phrase:'Any food?'},
           {key:'plant',cn:'æ¤ç‰©',ipa:'plÉ‘Ënt',phrase:'Any plants?'},
           {key:'animal',cn:'åŠ¨ç‰©',ipa:'ËˆÃ¦nÉªmÉ™l',phrase:'Any animal products?'},
           {key:'quarantine',cn:'æ£€ç–«/éš”ç¦»',ipa:'ËˆkwÉ’rÉ™ntiËn',phrase:'This item is in quarantine.'},
           {key:'inspection',cn:'æ£€æŸ¥',ipa:'ÉªnËˆspÉ›kÊƒÉ™n',phrase:'We need an inspection.'},
           {key:'receipt',cn:'æ”¶æ®',ipa:'rÉªËˆsiËt',phrase:'Keep the receipt.'}],
      };

      function App(){
        const ROWS=DEFAULT_ROWS, COLS=DEFAULT_COLS, MOVES=20;
        const [level,setLevel]=React.useState(1);
        const WORDS=React.useMemo(()=>LEVELS[level],[level]);
        const [unlocked,setUnlocked]=React.useState(()=>{try{const raw=localStorage.getItem('wm_unlocked');if(raw){return new Set(JSON.parse(raw))}}catch{}return new Set([1])});
        React.useEffect(()=>{try{localStorage.setItem('wm_unlocked',JSON.stringify(Array.from(unlocked)))}catch{}},[unlocked]);

        const COLOR=['bg-blue-100 border-blue-300','bg-green-100 border-green-300','bg-yellow-100 border-yellow-300','bg-purple-100 border-purple-300','bg-rose-100 border-rose-300','bg-teal-100 border-teal-300','bg-orange-100 border-orange-300','bg-sky-100 border-sky-300'];

        const [grid,setGrid]=React.useState(()=>createInitialGrid(ROWS,COLS,WORDS.length));
        const [selected,setSelected]=React.useState(null);
        const swipeRef=React.useRef(null);
        const [dragTarget,setDragTarget]=React.useState(null);
        const justSwappedRef=React.useRef(false);
        const [score,setScore]=React.useState(0);
        const [movesLeft,setMovesLeft]=React.useState(MOVES);
        const [lastMatch,setLastMatch]=React.useState([]);
        const [bigFont,setBigFont]=React.useState(true);
        const [showChinese,setShowChinese]=React.useState(true);
        const [speakOnMatch,setSpeakOnMatch]=React.useState(true);
        const [isBusy,setIsBusy]=React.useState(false);
        const [passInfo,setPassInfo]=React.useState(null);

        const firstLoad=React.useRef(true);
        React.useEffect(()=>{ if(firstLoad.current){firstLoad.current=false;return;} resetGameForKinds(WORDS.length); },[level]);

        // â€”â€” è‡ªé€‚åº”ï¼šæŒ‰å®¹å™¨å®½åº¦è®¡ç®—æ ¼å­å¤§å° â€”â€” 
        const boardWrapRef=React.useRef(null);
        const [cellPx,setCellPx]=React.useState(96);
        React.useEffect(()=>{
          const recompute=()=>{
            const avail=boardWrapRef.current?.clientWidth ?? (window.innerWidth-32);
            const gap=bigFont?8:6, maxCell=bigFont?96:80;
            setCellPx(computeCellPx(avail,COLS,gap,maxCell,52));
          };
          recompute();
          window.addEventListener('resize',recompute);
          window.addEventListener('orientationchange',recompute);
          return ()=>{window.removeEventListener('resize',recompute);window.removeEventListener('orientationchange',recompute)};
        },[COLS,bigFont]);

        const COMMIT_THRES=Math.min(48,Math.max(28,Math.round(cellPx*0.45)));
        const PREVIEW_THRES=Math.round(COMMIT_THRES*0.6);

        const speak=(t)=>{try{const u=new SpeechSynthesisUtterance(t);u.lang='en-GB';u.rate=0.9;window.speechSynthesis?.speak(u);}catch{}};

        function createInitialGrid(rows,cols,kinds){const g=Array.from({length:rows},()=>Array(cols).fill(0));for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){let tries=0;do{g[r][c]=Math.floor(Math.random()*kinds);tries++;}while((createsRun(g,r,c,cols)||createsRunVertical(g,r,c,rows))&&tries<50)}}return g}
        function createsRun(g,r,c,C){const v=g[r][c];return (c>=2&&g[r][c-1]===v&&g[r][c-2]===v)||(c>=1&&c+1<C&&g[r][c-1]===v&&g[r][c+1]===v)||(c+2<C&&g[r][c+1]===v&&g[r][c+2]===v)}
        function createsRunVertical(g,r,c,R){const v=g[r][c];return (r>=2&&g[r-1][c]===v&&g[r-2][c]===v)||(r>=1&&r+1<R&&g[r-1][c]===v&&g[r+1][c]===v)||(r+2<R&&g[r+1][c]===v&&g[r+2][c]===v)}
        function findMatches(g){const toClear=new Set();for(let r=0;r<ROWS;r++){let s=0;for(let c=1;c<=COLS;c++){if(c<COLS&&g[r][c]===g[r][c-1])continue;const L=c-s;if(L>=3){for(let k=s;k<c;k++)toClear.add(`${r},${k}`)}s=c}}for(let c=0;c<COLS;c++){let s=0;for(let r=1;r<=ROWS;r++){if(r<ROWS&&g[r][c]===g[r-1][c])continue;const L=r-s;if(L>=3){for(let k=s;k<r;k++)toClear.add(`${k},${c}`)}s=r}}const coords=[];toClear.forEach(key=>{const [rs,cs]=key.split(',').map(Number);coords.push({r:rs,c:cs,v:g[rs][cs]})});return coords}
        const cloneGrid=g=>g.map(r=>r.slice());
        function collapseAndRefill(g){for(let c=0;c<COLS;c++){let w=ROWS-1;for(let r=ROWS-1;r>=0;r--){if(g[r][c]!==-1){g[w][c]=g[r][c];w--;}}for(let r=w;r>=0;r--){g[r][c]=Math.floor(Math.random()*WORDS.length)}}}
        async function resolveMatchesCascade(base){let total=0;let g=cloneGrid(base);let uniq=new Set();while(true){const m=findMatches(g);if(m.length===0)break;total+=m.length;m.forEach(x=>uniq.add(x.v));m.forEach(({r,c})=>g[r][c]=-1);collapseAndRefill(g)}return {g,totalCleared:total,uniqueWords:Array.from(uniq)}}
        const areAdjacent=(a,b)=>Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1;
        async function trySwap(a,b){if(!areAdjacent(a,b))return;setIsBusy(true);const g=cloneGrid(grid);[g[a.r][a.c],g[b.r][b.c]]=[g[b.r][b.c],g[a.r][a.c]];const m0=findMatches(g);if(m0.length===0){setSelected(null);setIsBusy(false);return}const {g:after,totalCleared,uniqueWords}=await resolveMatchesCascade(g);setGrid(after);const newScore=score+totalCleared*10;if((level===1||level===2)&&shouldUnlockNext(level,newScore)){const next=level===1?2:3;if(!unlocked.has(next)&&!passInfo){setUnlocked(s=>{const n=new Set(s);n.add(next);return n});setPassInfo({level,next});setTimeout(()=>{setPassInfo(null);setLevel(next)},1800)}}setScore(newScore);setMovesLeft(m=>Math.max(0,m-1));setLastMatch(uniqueWords);if(speakOnMatch&&uniqueWords.length>0)speak(WORDS[safeIndex(uniqueWords[0],WORDS.length)].key);setSelected(null);setIsBusy(false)}

        const onPointerDown=(r,c)=>(e)=>{try{e.currentTarget.setPointerCapture(e.pointerId)}catch{};swipeRef.current={r,c,x:e.clientX,y:e.clientY,id:e.pointerId};setSelected({r,c})};
        const onPointerMove=(r,c)=>(e)=>{const s=swipeRef.current;if(!s||s.id!==e.pointerId)return;const dx=e.clientX-s.x,dy=e.clientY-s.y;const dir=directionFromDelta(dx,dy,PREVIEW_THRES);if(!dir){setDragTarget(null);return}setDragTarget(neighborFromDirection(s.r,s.c,dir,ROWS,COLS))};
        const onPointerUp=(r,c)=>(e)=>{const s=swipeRef.current;const dx=s?e.clientX-s.x:0,dy=s?e.clientY-s.y:0;const dir=directionFromDelta(dx,dy,COMMIT_THRES);if(s&&s.id===e.pointerId&&dir&&!isBusy&&movesLeft>0){const nbr=neighborFromDirection(s.r,s.c,dir,ROWS,COLS);if(nbr){justSwappedRef.current=true;trySwap({r:s.r,c:s.c},nbr)}}setSelected(null);setDragTarget(null);swipeRef.current=null};
        const onTileClick=(r,c)=>{if(justSwappedRef.current){justSwappedRef.current=false;return}if(isBusy||movesLeft===0)return;if(!selected){setSelected({r,c})}else{const here={r,c};if(selected.r===r&&selected.c===c)setSelected(null);else if(areAdjacent(selected,here))trySwap(selected,here);else setSelected(here)}};

        const resetGameForKinds=(k)=>{setGrid(createInitialGrid(ROWS,COLS,k));setSelected(null);setScore(0);setMovesLeft(MOVES);setLastMatch([])};
        const resetGame=()=>resetGameForKinds(WORDS.length);
        const shuffleBoard=()=>{if(isBusy)return;const flat=grid.flat();const kinds=WORDS.length;if(kinds<=1)return;let t=0;while(t<40){const sh=fisherYates(flat);const g2=Array.from({length:ROWS},(_,r)=>sh.slice(r*COLS,(r+1)*COLS));if(!hasImmediateMatches(g2,ROWS,COLS)){setGrid(g2);setSelected(null);setDragTarget(null);setLastMatch([]);return}t++}setGrid(createInitialGrid(ROWS,COLS,kinds));setSelected(null);setDragTarget(null);setLastMatch([])};
        const chooseLevel=(lv)=>{if(lv===level)return;if(!unlocked.has(lv))return;setLevel(lv)};

        return (<div className="min-h-screen w-full bg-white text-gray-900 flex flex-col items-center p-4 md:p-6">
          <div className="w-full max-w-6xl">
            <header className="flex flex-col md:flex-row md:items-end md:justify-between gap-3 mb-4">
              <div>
                <h1 className="text-2xl md:text-3xl font-bold">æ¶ˆæ¶ˆä¹å­¦å•è¯ï¼ˆæµ·å…³è¯æ±‡Â·ä¸‰å…³ï¼‰</h1>
                <p className="text-gray-700 mt-1">ç©æ³•ï¼ˆæ‰‹æœºï¼‰ï¼šæŒ‰ä½æ ¼å­å‘ä¸Šä¸‹å·¦å³æ»‘åŠ¨è¿›è¡Œäº¤æ¢ï¼›ï¼ˆç”µè„‘ï¼‰ï¼šç‚¹å‡»ä¸€ä¸ªæ ¼å­å†ç‚¹ç›¸é‚»æ ¼å­ã€‚è¿æˆ3ä¸ªæˆ–ä»¥ä¸Šç›¸åŒå•è¯å³å¯æ¶ˆé™¤å¹¶å­¦ä¹ ã€‚</p>
              </div>
              <div className="flex gap-2 flex-wrap items-center">
                <div className="flex gap-2">
                  {[1,2,3].map(lv => (<button key={lv} onClick={()=>chooseLevel(lv)} disabled={!unlocked.has(lv)} className={`px-4 py-2 rounded-2xl shadow border text-base md:text-lg ${level===lv?'bg-blue-50 border-blue-300':''} ${!unlocked.has(lv)?'opacity-60 cursor-not-allowed':''}`} aria-pressed={level===lv} aria-disabled={!unlocked.has(lv)}>{lv===1?'ç¬¬ä¸€å…³ï¼ˆ6è¯ï¼‰':lv===2?'ç¬¬äºŒå…³ï¼ˆ10è¯ï¼‰':'ç¬¬ä¸‰å…³ï¼ˆ14è¯ï¼‰'}</button>))}
                </div>
                <button onClick={()=>setBigFont(v=>!v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={bigFont}>{bigFont?'å¤§å­—æ¨¡å¼ï¼šå¼€':'å¤§å­—æ¨¡å¼ï¼šå…³'}</button>
                <button onClick={()=>setShowChinese(v=>!v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={showChinese}>{showChinese?'ä¸­æ–‡æç¤ºï¼šå¼€':'ä¸­æ–‡æç¤ºï¼šå…³'}</button>
                <button onClick={()=>setSpeakOnMatch(v=>!v)} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-pressed={speakOnMatch}>{speakOnMatch?'è¯»éŸ³ï¼šå¼€':'è¯»éŸ³ï¼šå…³'}</button>
                <button onClick={resetGame} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg">é‡æ–°å¼€å§‹</button>
                <button onClick={shuffleBoard} disabled={isBusy} className="px-4 py-2 rounded-2xl shadow border text-base md:text-lg" aria-label="æ‰“ä¹±å½“å‰æ£‹ç›˜ï¼Œä¸æ‰£æ­¥">æ‰“ä¹±ä¸€ä¸‹ï¼ˆä¸æ‰£æ­¥ï¼‰</button>
              </div>
            </header>

            <main className="grid md:grid-cols-[1fr_auto_1fr] gap-4">
              <aside className="rounded-2xl border p-4 shadow-sm">
                <div className="text-lg md:text-xl font-semibold mb-2">æœ¬å…³ç›®æ ‡ï¼ˆå…³å¡ï¼š{level}ï¼‰</div>
                <ul className="text-base leading-relaxed"><li>Â· è®¤è¯†å¹¶èƒ½è¯»å‡ºæœ¬å…³æµ·å…³è¯æ±‡</li><li>Â· æ¯æ¬¡æ¶ˆé™¤åçœ‹å¡ç‰‡ï¼Œè·Ÿè¯» 1 é</li></ul>
                <div className="mt-3 text-base">
                  <div>æ­¥æ•°ï¼š<span className="font-bold">{movesLeft}</span></div>
                  <div>å¾—åˆ†ï¼š<span className="font-bold">{score}</span></div>
                  {(level===1||level===2)&&(<div className="mt-1 text-sm text-gray-600">è¾¾åˆ° <b>{LEVEL_TARGET[level]}</b> åˆ†å°†è§£é”ä¸‹ä¸€å…³</div>)}
                </div>
                <div className="mt-4">
                  <div className="text-base md:text-lg font-medium mb-2">æœ¬å…³è¯æ±‡ï¼ˆ{WORDS.length}ä¸ªï¼‰</div>
                  <div className="flex flex-wrap gap-2">{WORDS.map(w=>(<span key={w.key} className="px-2 py-1 rounded-xl border text-sm md:text-base">{w.key}{showChinese?` Â· ${w.cn}`:''}</span>))}</div>
                </div>
              </aside>

              <section className="flex flex-col items-center w-full">
                <div ref={boardWrapRef} className="w-full">
                  <div className="grid" style={{gridTemplateColumns:`repeat(${COLS}, ${cellPx}px)`,gridTemplateRows:`repeat(${ROWS}, ${cellPx}px)`,gap:bigFont?8:6,touchAction:'none'}}>
                    {grid.map((row,r)=>row.map((v,c)=>{
                      const isSel=selected?.r===r&&selected?.c===c;
                      const color=COLOR[v%COLOR.length];
                      const tile=`select-none ${color} border-2 rounded-2xl shadow-sm flex items-center justify-center cursor-pointer hover:shadow-md transition text-center whitespace-nowrap truncate leading-tight px-2 overflow-hidden`;
                      const keyStr=WORDS[safeIndex(v,WORDS.length)].key;
                      return (<button key={`${r}-${c}`} onClick={()=>onTileClick(r,c)} onPointerDown={onPointerDown(r,c)} onPointerMove={onPointerMove(r,c)} onPointerUp={onPointerUp(r,c)} className={tile+(isSel?' ring-4 ring-blue-400':'')+(dragTarget&&dragTarget.r===r&&dragTarget.c===c?' ring-4 ring-emerald-400':'')+(isBusy?' opacity-80':'')} style={{fontSize:fitFontPx(keyStr,bigFont?26:22,cellPx),fontWeight:800,lineHeight:1.1}} aria-label={`ç¬¬${r+1}è¡Œç¬¬${c+1}åˆ—ï¼š${keyStr}`}>{keyStr}</button>)
                    }))}
                  </div>
                </div>
                {movesLeft===0&&(<div className="mt-4 p-4 rounded-2xl border shadow bg-gray-50 text-center"><div className="text-lg md:text-xl font-bold mb-1">æœ¬å±€ç»“æŸ</div><div className="mb-2">å¾—åˆ†ï¼š{score}ã€‚{(level===1||level===2)?`è¾¾åˆ° ${LEVEL_TARGET[level]} åˆ†å°†è§£é”ä¸‹ä¸€å…³ã€‚`:'å·²æ˜¯æœ€åä¸€å…³ã€‚'}</div><button onClick={resetGame} className="px-4 py-2 rounded-2xl shadow border">å†æ¥ä¸€å±€</button></div>)}
              </section>

              <aside className="rounded-2xl border p-4 shadow-sm">
                <div className="text-lg md:text-xl font-semibold mb-2">å­¦ä¹ å¡ç‰‡</div>
                {lastMatch.length===0?(<p className="text-base text-gray-600">æ¶ˆé™¤åä¼šåœ¨è¿™é‡Œå‡ºç°å¡ç‰‡ã€‚</p>):(<div className="space-y-3">{lastMatch.map(idx=>{const w=WORDS[safeIndex(idx,WORDS.length)];return (<div key={w.key} className="p-3 rounded-xl border bgç™½ shadow-sm"><div className="flex items-center justify-between"><div className="text-xl md:text-2xl font-bold">{w.key}</div><button className="px-3 py-1 rounded-xl border text-sm" onClick={()=>speak(w.key)} aria-label={`æ’­æ”¾ ${w.key} çš„è¯»éŸ³`}>ğŸ”Š å‘éŸ³</button></div><div className="text-sm text-gray-600 mt-1">/{w.ipa}/</div>{showChinese&&<div className="mt-1 text-base">ä¸­æ–‡ï¼š{w.cn}</div>}<div className="mt-1 text-base italic">ä¾‹å¥ï¼š{w.phrase}</div></div>)})}</div>)}
                <div className="mt-4 text-sm text-gray-600 leading-relaxed">å°è´´å£«ï¼šé•¿æŒ‰â€œğŸ”Š å‘éŸ³â€åè·Ÿè¯» 1 éï¼›æ¯å¤©ç© 10 åˆ†é’Ÿï¼Œè¿›æ­¥æ›´å¿«ã€‚</div>
              </aside>
            </main>

            <footer className="mt-6 text-sm text-gray-500">æ— è®¡æ—¶ Â· è¯¯è§¦å¯å–æ¶ˆé€‰æ‹© Â· é«˜å¯¹æ¯”åº¦é…è‰² Â· å¯åˆ‡æ¢ä¸­æ–‡æç¤ºä¸è¯»éŸ³</footer>
          </div>

          {passInfo&&(<div className="å›ºå®š inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50"><div className="bg-white rounded-2xl shadow-xl p-6 w-[min(90vw,520px)] text-center"><div className="text-2xl font-bold mb-2">ğŸ‰ æ­å–œè¿‡å…³ï¼</div><div className="text-base mb-3">ä½ å·²è¾¾åˆ°æœ¬å…³ç›®æ ‡åˆ†æ•°ï¼ˆâ‰¥ {LEVEL_TARGET[level]} åˆ†ï¼‰ã€‚å°†è¿›å…¥<b> ç¬¬{passInfo.next===2?'äºŒ':'ä¸‰'}å…³</b> â€¦</div><div className="text-sm text-gray-600 mb-4">å°†è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³ï¼ˆçº¦ 1.8 ç§’ï¼‰ã€‚</div><div className="flex justify-center gap-2"><button className="px-4 py-2 rounded-2xl border shadow" onClick={()=>{setPassInfo(null);setLevel(passInfo.next)}}>ç«‹å³è¿›å…¥</button><button className="px-4 py-2 rounded-2xl border" onClick={()=>setPassInfo(null)}>ç¨å</button></div></div><span className="sr-only" aria-live="assertive">æ­å–œè¿‡å…³ï¼Œæ­£åœ¨ä¸ºä½ è¿›å…¥ä¸‹ä¸€å…³</span></div>)}
        </div>);
      }

      ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
    </script>
  </body>
</html>
